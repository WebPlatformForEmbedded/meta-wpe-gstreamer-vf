From 44af503b6dfdd2ef238ed55d77ac69c0b3f52e82 Mon Sep 17 00:00:00 2001
From: krp97 <k.plata576@gmail.com>
Date: Thu, 12 Aug 2021 07:40:26 +0000
Subject: [PATCH] Adjust condition for freezing the system clock

This patch removes a condition that prevents the STC from going
into a frozen / ruuning state, based on an internal variable.
Since the underlying function can be called from any element
in bcm's gst, this might lead to inconsistencies in this variable's
value.

Additionally, during a state change to paused the audio decoder
is started which results in ~1s of buffers being displayed
(audio and video). This commit reverts that behavior.

TODO: File this as an issue with bcm and investigate further.
---
 reference/audiodecode/src/gst_brcm_audio_decoder.c |  6 ------
 reference/util/src/gst_system_clock.c              | 16 ++++++----------
 2 files changed, 6 insertions(+), 16 deletions(-)

diff --git a/reference/audiodecode/src/gst_brcm_audio_decoder.c b/reference/audiodecode/src/gst_brcm_audio_decoder.c
index 2a95a3a..124732a 100755
--- a/reference/audiodecode/src/gst_brcm_audio_decoder.c
+++ b/reference/audiodecode/src/gst_brcm_audio_decoder.c
@@ -1314,12 +1314,6 @@ static GstStateChangeReturn gst_brcm_audio_decoder_change_state(GstElement *elem
             GST_LOG("transition READY_TO_PAUSED - Invalid Audio codec. Retry on sink set caps");
             break;
         }
-
-        BRCM_G_MUTEX_LOCK(decoder->mutex);
-        gst_brcm_audio_decoder_start(decoder);
-
-        GST_LOG("transition: READY_TO_PAUSED");
-        BRCM_G_MUTEX_UNLOCK(decoder->mutex);
         break;
     }
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
diff --git a/reference/util/src/gst_system_clock.c b/reference/util/src/gst_system_clock.c
index 0ba502b..79a8a73 100755
--- a/reference/util/src/gst_system_clock.c
+++ b/reference/util/src/gst_system_clock.c
@@ -183,20 +183,16 @@ void gst_brcm_system_clock_freeze_stc_channel(NEXUS_SimpleStcChannelHandle stc_c
         BDBG_WRN(("Stc channel not found"));
     } else {
         if (freeze) {
-            if (!sysclock.clock[token_id].frozen[SYS_CLK_CLIENT_VIDEO] && !sysclock.clock[token_id].frozen[SYS_CLK_CLIENT_AUDIO]){
-                NEXUS_Error rc = NEXUS_SimpleStcChannel_Freeze(stc_channel, true);
-                if (rc) {
-                    BDBG_WRN(("NEXUS_SimpleStcChannel_Freeze failed %d", GST_FUNCTION,__LINE__, rc));
-                }
+            NEXUS_Error rc = NEXUS_SimpleStcChannel_Freeze(stc_channel, true);
+            if (rc) {
+                BDBG_WRN(("NEXUS_SimpleStcChannel_Freeze failed %d", GST_FUNCTION,__LINE__, rc));
             }
             sysclock.clock[token_id].frozen[sys_clk_client] = true;
         } else { /* freeze == 0 */
             sysclock.clock[token_id].frozen[sys_clk_client] = false;
-            if (!sysclock.clock[token_id].frozen[SYS_CLK_CLIENT_VIDEO] && !sysclock.clock[token_id].frozen[SYS_CLK_CLIENT_AUDIO]){
-                NEXUS_Error rc = NEXUS_SimpleStcChannel_Freeze(stc_channel, false);
-                if (rc) {
-                    BDBG_WRN(("NEXUS_SimpleStcChannel_Freeze failed %d", GST_FUNCTION,__LINE__, rc));
-                }
+            NEXUS_Error rc = NEXUS_SimpleStcChannel_Freeze(stc_channel, false);
+            if (rc) {
+                BDBG_WRN(("NEXUS_SimpleStcChannel_Freeze failed %d", GST_FUNCTION,__LINE__, rc));
             }
         }
     }
-- 
2.7.4

