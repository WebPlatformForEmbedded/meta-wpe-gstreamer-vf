From 7415034c3348d5106e86a33954b76b0299bebe6e Mon Sep 17 00:00:00 2001
From: "k.plata" <k.plata@metrological.com>
Date: Thu, 7 Apr 2022 16:17:00 +0000
Subject: [PATCH 2/6] BCMCZ-379 Refactor position query handling

This commit refactors position query handling in the video decoder,
with the following changes:
  - recalculate_position function is removed, in favour of using
    a generic gstreamer function (`gst_segment_to_stream_time`),
  - query_position function is reworked, so that it now uses
    `gst_segment_to_stream_time` for absolute position calculation,
  - formatting fixes to break up long lines of code.

These changes also address an issue, where the video decoder did not
respond to position queries for a prolonged time during startup.
A position query should be handled, as soon as a segment event has
been processed.

Change-Id: Ia7bd7fe4c223800ffd3517f07e54ee441f1f5f98
---
 reference/videodecode/src/gst_brcm_video_decoder.c | 80 +++++++++++-----------
 reference/videodecode/src/gst_brcm_video_decoder.h |  1 +
 2 files changed, 42 insertions(+), 39 deletions(-)

diff --git a/reference/videodecode/src/gst_brcm_video_decoder.c b/reference/videodecode/src/gst_brcm_video_decoder.c
index 80e05ea..753503f 100755
--- a/reference/videodecode/src/gst_brcm_video_decoder.c
+++ b/reference/videodecode/src/gst_brcm_video_decoder.c
@@ -509,11 +509,6 @@ static void gst_brcm_video_decoder_class_init (GstBrcmVideoDecoderClass *klass)
 // need to be enabled to make videoplane zorder to work.
 #define SET_GRAPHIC_SURFACE 0
 
-static gint64 recalculate_position(GstBrcmVideoDecoder *decoder)
-{
-    return decoder->start_position + decoder->position * decoder->applied_rate;
-}
-
 static void complete2(void *context, int param)
 {
     BSTD_UNUSED(param);
@@ -787,7 +782,7 @@ static void gst_brcm_video_decoder_init(GstBrcmVideoDecoder *decoder) {
     decoder->enable_vsync_mode = FALSE;
     decoder->treat_iframe_as_rap = FALSE;
 
-
+    decoder->current_segment = NULL;
     decoder->enable_limit_buffering = FALSE;
     decoder->verify_decode_timer = 0;
     decoder->brcm_async = brcm_asyncthread_open(BRCM_ASYNCTHREAD_DEF_NUM_THREADS);
@@ -1138,12 +1133,21 @@ static void video_update_pts_vars(GstBrcmVideoDecoder *decoder, unsigned int new
         decoder->current_pts_valid = TRUE;
 
         decoder->position = decoder->start_position + (((gint64)decoder->current_pts - ((gint64)decoder->first_pts + decoder->disco_adjust_pts)) * GST_MSECOND) / 45;
-        GST_TRACE("current_pts=%ldms firstPts=%ldms disco_adjust_pts=%lldms delta=%ldms position=%llums start_position=%llums", decoder->current_pts/45, decoder->first_pts/45, decoder->disco_adjust_pts/45, (long int)(decoder->current_pts - (decoder->first_pts + decoder->disco_adjust_pts))/45, decoder->position/GST_MSECOND, decoder->start_position/GST_MSECOND);
+
+        GST_TRACE("current_pts=%ldms firstPts=%ldms disco_adjust_pts=%lldms delta=%ldms position=%llums start_position=%llums"
+            , decoder->current_pts / 45
+            , decoder->first_pts / 45
+            , decoder->disco_adjust_pts / 45
+            , (long int)(decoder->current_pts - (decoder->first_pts + decoder->disco_adjust_pts)) / 45
+            , decoder->position/GST_MSECOND, decoder->start_position / GST_MSECOND);
+
         if (ABS(decoder->position - decoder->position_keeper) >= ABS(decoder->position_timer * rate)) {
-            GST_TRACE("rate: %f position: %"G_GINT64_FORMAT" diff: %"G_GINT64_FORMAT,
-                    rate, recalculate_position(decoder), (decoder->position - decoder->position_keeper));
             decoder->position_keeper = decoder->position;
-            g_signal_emit (G_OBJECT (decoder), position_change_signal, 0, recalculate_position(decoder) , NULL);
+
+            guint64 position = gst_segment_to_stream_time(decoder->current_segment, GST_FORMAT_TIME, decoder->position);
+            g_signal_emit (G_OBJECT (decoder), position_change_signal, 0, position , NULL);
+            GST_TRACE("rate: %f position: %"G_GINT64_FORMAT" diff: %"G_GINT64_FORMAT,
+                rate, position, (decoder->position - decoder->position_keeper));
         }
     }
 }
@@ -2971,6 +2975,12 @@ static gboolean gst_brcm_video_decoder_sink_event(GstPad *pad, GstObject *parent
         decoder->log_buffers_cnt = 0;
         decoder->eos_seen = FALSE;
         decoder->ignore_disco = TRUE;
+        
+        if(decoder->current_segment) {
+            gst_segment_free(decoder->current_segment);
+            decoder->current_segment = NULL;
+        }
+
         stop_eos_timer(decoder, "GST_EVENT_FLUSH_START");
         NEXUS_SimpleVideoDecoder_Flush(decoder->video_decoder);
         decoder->num_pics_decoded = 0;
@@ -3005,6 +3015,7 @@ static gboolean gst_brcm_video_decoder_sink_event(GstPad *pad, GstObject *parent
         else
             decoder->ignore_disco_during_trick = FALSE;
 
+        decoder->current_segment = gst_segment_copy(dataSegment);
         decoder->applied_rate = applied_rate;
         decoder->stop_position = segStop;
         decoder->start_position = segStart;
@@ -3014,7 +3025,8 @@ static gboolean gst_brcm_video_decoder_sink_event(GstPad *pad, GstObject *parent
 
         if (segFormat == GST_FORMAT_TIME) {
             uint32_t start_pts = (GST_TIME_AS_MSECONDS(segStart) * 45);
-            GST_INFO("GST_EVENT_NEWSEGMENT start_pts 0x%x segStart %"G_GINT64_FORMAT"ms, segPos %"G_GINT64_FORMAT"ms ", start_pts, (segStart/GST_MSECOND), (segPos/GST_MSECOND));
+            GST_INFO("New segment - start: %"GST_TIME_FORMAT", position: %"GST_TIME_FORMAT", stop: %"GST_TIME_FORMAT", nexus decoder startPts: %u)"
+                , GST_TIME_ARGS(segStart), GST_TIME_ARGS(segPos), GST_TIME_ARGS(segStop), start_pts);
 
             if (segStart == 0) {
                 NEXUS_VideoDecoderStatus decoderStatus;
@@ -3041,7 +3053,8 @@ static gboolean gst_brcm_video_decoder_sink_event(GstPad *pad, GstObject *parent
         }
 
         gst_brcm_video_decoder_limiting_force_leave(decoder);
-        g_signal_emit (G_OBJECT (decoder), position_change_signal, 0, recalculate_position(decoder) , NULL);
+        guint64 stream_time = gst_segment_to_stream_time(dataSegment, GST_FORMAT_TIME, decoder->position);
+        g_signal_emit (G_OBJECT (decoder), position_change_signal, 0, stream_time, NULL);
         decoder->position_keeper = decoder->position;
         break;
     }
@@ -3409,35 +3422,24 @@ static void gst_brcm_video_decoder_sink_unlink(GstPad *pad, GstObject *parent) {
 }
 
 static gboolean query_position(GstPad *pad, GstObject *parent, GstQuery *query) {
+    GstBrcmVideoDecoder *decoder = GST_BRCM_VIDEO_DECODER(parent);
+    GstFormat format;
+    gboolean rv = FALSE;  
 
-  GstBrcmVideoDecoder *decoder = GST_BRCM_VIDEO_DECODER(parent);
-  GstFormat format;
-  gboolean rv = FALSE;
-
-  gst_query_parse_position(query, &format, NULL);
-  if(format == GST_FORMAT_BYTES)
-      rv = gst_pad_query_default(pad, parent, query);
-  else
-  {
-      gint64 position, duration;
-      GstFormat fmt = GST_FORMAT_TIME;
-      gboolean ret;
-
-      if (!decoder->num_pics_decoded) {   /* position info not valid */
-          return FALSE;
-      }
+    if(format == GST_FORMAT_BYTES) {
+        rv = gst_pad_query_default(pad, parent, query);
+    } else if(decoder->current_segment != NULL) { 
+        guint64 position = gst_segment_to_stream_time(decoder->current_segment, GST_FORMAT_TIME, decoder->position);
+        gst_query_set_position(query, GST_FORMAT_TIME, position);
 
-      position = decoder->start_position + (decoder->position - decoder->start_position) * decoder->applied_rate;
-      if (decoder->applied_rate < 0) { /* reverse playback */
-          ret = gst_pad_query_duration(pad,fmt,&duration);
-          if (ret)
-              position = decoder->stop_position + decoder->position*decoder->applied_rate;
-      }
-      gst_query_set_position(query, GST_FORMAT_TIME, position);
-      GST_LOG("video_decoder: position %lldns (%lldms), decoder->start_position %lldns (%lldms), decoder->position %lldns (%lldms)", position, position/GST_MSECOND, decoder->start_position, decoder->start_position/GST_MSECOND, decoder->position, decoder->position/GST_MSECOND);
-      rv = TRUE;
-  }
-  return rv;
+        GST_LOG("position: %"GST_TIME_FORMAT", segment start: %"GST_TIME_FORMAT", segment: %"GST_TIME_FORMAT""
+            , GST_TIME_ARGS(position)
+            , GST_TIME_ARGS(decoder->start_position)
+            , GST_TIME_ARGS(decoder->position));
+
+        rv = TRUE;
+    }
+    return rv;
 }
 
 static gboolean gst_brcm_video_decoder_src_query(GstPad *pad, GstObject *parent, GstQuery *query) {
diff --git a/reference/videodecode/src/gst_brcm_video_decoder.h b/reference/videodecode/src/gst_brcm_video_decoder.h
index bfea717..e5ae0c4 100755
--- a/reference/videodecode/src/gst_brcm_video_decoder.h
+++ b/reference/videodecode/src/gst_brcm_video_decoder.h
@@ -158,6 +158,7 @@ struct _GstBrcmVideoDecoder
     gint64 start_position;                      /* start position when applied_rate>1*/
     gboolean ignore_disco_during_trick;         /* ignore looking for discontinuity during trick */
     gdouble segment_rate;
+    GstSegment* current_segment;
 
     GThread *worker;
     BRCM_G_MUTEX mutex;
-- 
2.7.4

